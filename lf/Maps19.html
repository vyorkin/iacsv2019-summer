<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>Maps19</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf19.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
</br><a href='index.html'>  <span class='booktitleinheader'>Volume 1: Logical Foundations 19</span><br></br>
<ul id='menu'>
   <a href='toc.html'><li class='section_name'>Table of Contents</li></a>
   <a href='coqindex.html'><li class='section_name'>Index</li></a>
   <a href='deps.html'><li class='section_name'>Roadmap</li></a>
</ul>
</a></div>

<div id="main">

<h1 class="libtitle">Maps19</h1>


<div class="doc">

<div class="paragraph"> </div>

 Adapted for SemProg@FAU 2013&mdash;2019 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Set</span> <span class="id" type="var">Warnings</span> "-notation-overridden,-parsing".<br/>
<span class="id" type="var">From</span> <span class="id" type="var">Coq</span> <span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">ssreflect</span> <span class="id" type="var">ssrbool</span> <span class="id" type="var">ssrfun</span>.<br/>
</div>

<div class="doc">
This time, we import more than usual! 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Coq.Bool.Bool</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <span class="id" type="var">Coq.Strings.String</span>.<br/>
</div>

<div class="doc">
Aaand this. Do you still remember what it was? 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Coq.Logic.FunctionalExtensionality</span>.<br/>
</div>

<div class="doc">
<a name="lab191"></a><h2 class="section">Maps: Total and Partial Maps</h2>

<div class="paragraph"> </div>

 Maps (or dictionaries) are ubiquitous data structures, both in
    software construction generally and in the theory of programming
    languages in particular; we're going to need them in many places
    in the coming chapters.  They also make a nice case study using
    ideas we've seen in previous chapters, including building data
    structures out of higher-order functions (from <span class="inlinecode"><span class="id" type="var">Basics</span></span> and
    <span class="inlinecode"><span class="id" type="var">Poly</span></span>) and the use of reflection to streamline proofs (from
    <span class="inlinecode"><span class="id" type="var">IndProp</span></span>).

<div class="paragraph"> </div>

    We'll define two flavors of maps: <i>total</i> maps, which include a
    "default" element to be returned when a key being looked up
    doesn't exist, and <i>partial</i> maps, which return an <span class="inlinecode"><span class="id" type="var">option</span></span> to
    indicate success or failure.  The latter is defined in terms of
    the former, using <span class="inlinecode"><span class="id" type="var">None</span></span> as the default element. 
</div>

<div class="doc">
<a name="lab192"></a><h2 class="section">Identifiers</h2>

<div class="paragraph"> </div>

 First, we need a type for the keys that we use to index into our
    maps.  For this purpose, we will simply use plain <span class="inlinecode"><span class="id" type="var">string</span></span>s.  Yes, Coq  has them!
<div class="paragraph"> </div>

 To compare strings, we define the function <span class="inlinecode"><span class="id" type="var">beq_string</span></span>, which
    internally uses the function <span class="inlinecode"><span class="id" type="var">string_dec</span></span> from Coq's string library.
    We then establish its fundamental properties. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">beq_string</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">string_dec</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="keyword">then</span> <span class="id" type="var">true</span> <span class="id" type="keyword">else</span> <span class="id" type="var">false</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li>  The function <span class="inlinecode"><span class="id" type="var">string_dec</span></span> comes from Coq's string library.

</li>
<li>  The result type of <span class="inlinecode"><span class="id" type="var">string_dec</span></span> is neither <span class="inlinecode"><span class="id" type="var">bool</span></span> nor <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>, but rather a type that looks
    like <span class="inlinecode">{<span class="id" type="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">y</span>}</span> <span class="inlinecode">+</span> <span class="inlinecode">{<span class="id" type="var">x</span></span> <span class="inlinecode">≠</span> <span class="inlinecode"><span class="id" type="var">y</span>}</span>, called a <span class="inlinecode"><span class="id" type="var">sumbool</span></span>, which can be
    thought of as an "evidence-carrying boolean."  

</li>
<li>  As you can imagine, it achieves something similar to reflect. 

</li>
<li>  This type is not uncommon to see in Coq developments, so let us practice with it a little. 
</li>
</ul>

</div>
<div class="code code-tight">

<span class="id" type="keyword">Check</span> <span class="id" type="var">string_dec</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">beq_stringP</span> {<span class="id" type="var">x</span> <span class="id" type="var">y</span>}: <span class="id" type="var">reflect</span> (<span class="id" type="var">x</span> = <span class="id" type="var">y</span>) (<span class="id" type="var">beq_string</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">case</span> <span class="id" type="var">E</span>: (<span class="id" type="var">beq_string</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>); <span class="id" type="var">constructor</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">case</span> <span class="id" type="var">S</span>: (<span class="id" type="var">string_dec</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) ⇒ [<span class="id" type="var">hP</span> | <span class="id" type="var">hP</span>] //;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> /<span class="id" type="var">beq_string</span> <span class="id" type="var">S</span> /<span class="id" type="var">is_left</span> <span class="id" type="keyword">in</span> <span class="id" type="var">E</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>
</div>

<div class="doc">
Do you understand what happened here? 
<div class="paragraph"> </div>

 Let us now put our reflection skills to good use... 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">beq_string_refl</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">s</span>, <span class="id" type="var">true</span> = <span class="id" type="var">beq_string</span> <span class="id" type="var">s</span> <span class="id" type="var">s</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">move</span> ⇒ <span class="id" type="var">s</span>. <span class="id" type="tactic">case</span> <span class="id" type="var">E</span>: (<span class="id" type="var">beq_string</span> <span class="id" type="var">s</span> <span class="id" type="var">s</span> ) ⇒ //.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">by</span> <span class="id" type="tactic">move</span> /<span class="id" type="var">beq_stringP</span> <span class="id" type="keyword">in</span>  <span class="id" type="var">E</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The following useful property of <span class="inlinecode"><span class="id" type="var">beq_string</span></span> follows from an
    analogous lemma about strings: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">beq_string_true_iff</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">string</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">beq_string</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> = <span class="id" type="var">true</span> ↔ <span class="id" type="var">x</span> = <span class="id" type="var">y</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">by</span> <span class="id" type="tactic">move</span> /<span class="id" type="var">beq_stringP</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">move</span> ⇒ →. <span class="id" type="tactic">by</span> <span class="id" type="tactic">rewrite</span> -<span class="id" type="var">beq_string_refl</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The next one could have been done similarly, but there's an even quicker way.
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">beq_string_false_iff</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">string</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">beq_string</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> = <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;↔ <span class="id" type="var">x</span> ≠ <span class="id" type="var">y</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">move</span> ⇒ <span class="id" type="var">x</span> <span class="id" type="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">by</span> <span class="id" type="tactic">rewrite</span> -<span class="id" type="var">beq_string_true_iff</span> <span class="id" type="var">not_true_iff_false</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
This useful variant follows just by rewriting: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">false_beq_string</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">string</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">x</span> ≠ <span class="id" type="var">y</span> → <span class="id" type="var">beq_string</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">move</span> ⇒ <span class="id" type="var">x</span> <span class="id" type="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">by</span> <span class="id" type="tactic">rewrite</span> <span class="id" type="var">beq_string_false_iff</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab193"></a><h2 class="section">Total Maps</h2>

<div class="paragraph"> </div>

 Our main job in this chapter is to build a definition of
    partial maps using <i>functions</i>, rather
    than lists of key-value pairs, to build maps.

<div class="paragraph"> </div>

<ul class="doclist">
<li> The advantage of
    this representation is that it offers an <i>extensional</i> view of
    maps: two maps that respond to queries in the same way will
    be represented as literally the same thing (the same function),
    rather than just "equivalent" data structures.. 
</li>
</ul>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    We build partial maps in two steps.  First, we define a type of
    <i>total maps</i> that return a default value when we look up a key
    that is not present in the map. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">total_map</span> (<span class="id" type="var">A</span>:<span class="id" type="keyword">Type</span>) := <span class="id" type="var">string</span> → <span class="id" type="var">A</span>.<br/>
</div>

<div class="doc">
Intuitively, a total map over an element type <span class="inlinecode"><span class="id" type="var">A</span></span> <i>is</i> just a
    function that can be used to look up <span class="inlinecode"><span class="id" type="var">id</span></span>s, yielding <span class="inlinecode"><span class="id" type="var">A</span></span>s. 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

    The function <span class="inlinecode"><span class="id" type="var">t_empty</span></span> yields an empty total map, given a default
    element; this map always returns the default element when applied
    to any id. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">t_empty</span> {<span class="id" type="var">A</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">v</span> : <span class="id" type="var">A</span>) : <span class="id" type="var">total_map</span> <span class="id" type="var">A</span> :=<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> ⇒ <span class="id" type="var">v</span>).<br/>
</div>

<div class="doc">
More interesting is the <span class="inlinecode"><span class="id" type="var">update</span></span> function, which (as before) takes
    a map <span class="inlinecode"><span class="id" type="var">m</span></span>, a key <span class="inlinecode"><span class="id" type="var">x</span></span>, and a value <span class="inlinecode"><span class="id" type="var">v</span></span> and returns a new map that
    takes <span class="inlinecode"><span class="id" type="var">x</span></span> to <span class="inlinecode"><span class="id" type="var">v</span></span> and takes every other key to whatever <span class="inlinecode"><span class="id" type="var">m</span></span> does. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">t_update</span> {<span class="id" type="var">A</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">m</span> : <span class="id" type="var">total_map</span> <span class="id" type="var">A</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">x</span> : <span class="id" type="var">string</span>) (<span class="id" type="var">v</span> : <span class="id" type="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> <span class="id" type="var">x'</span> ⇒ <span class="id" type="keyword">if</span> <span class="id" type="var">beq_string</span> <span class="id" type="var">x</span> <span class="id" type="var">x'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">v</span> <span class="id" type="keyword">else</span> <span class="id" type="var">m</span> <span class="id" type="var">x'</span>.<br/>
</div>

<div class="doc">
This definition is a nice example of higher-order programming.
    The <span class="inlinecode"><span class="id" type="var">t_update</span></span> function takes a <i>function</i> <span class="inlinecode"><span class="id" type="var">m</span></span> and yields a new
    function <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">x'</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode">...</span> that behaves like the desired map. 
<div class="paragraph"> </div>

 For example, we can build a map taking <span class="inlinecode"><span class="id" type="var">string</span></span>s to <span class="inlinecode"><span class="id" type="var">bool</span></span>s, where
    <span class="inlinecode">"<span class="id" type="var">foo</span>"</span> and <span class="inlinecode">"<span class="id" type="var">bar</span>"</span> are mapped to <span class="inlinecode"><span class="id" type="var">true</span></span> and every other key is
    mapped to <span class="inlinecode"><span class="id" type="var">false</span></span>, like this: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">examplemap</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">t_update</span> (<span class="id" type="var">t_update</span> (<span class="id" type="var">t_empty</span> <span class="id" type="var">false</span>) "foo" <span class="id" type="var">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"bar" <span class="id" type="var">true</span>.<br/>
</div>

<div class="doc">
It's awkward to write such things, so we define new notations. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Notation</span> "[&lt; n &gt;]" := (<span class="id" type="var">t_empty</span> <span class="id" type="var">n</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 30).<br/>
<span class="id" type="keyword">Notation</span> "st [&lt; x ~~&gt;&gt; n &gt;]" := (<span class="id" type="var">t_update</span> <span class="id" type="var">st</span> <span class="id" type="var">x</span> <span class="id" type="var">n</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 21, <span class="id" type="var">left</span> <span class="id" type="var">associativity</span>).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">examplemap</span>.<br/>
</div>

<div class="doc">
Also, let us note that there is  notation for string equality. 
</div>
<div class="code code-tight">

<span class="id" type="var">Search</span> "=?".<br/>
</div>

<div class="doc">
Moreover, the string library already provides reflection for equality ... 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Check</span> <span class="id" type="var">eqb_spec</span>.<br/>
</div>

<div class="doc">
This completes the definition of total maps.  Note that we don't
    need to define a <span class="inlinecode"><span class="id" type="var">find</span></span> operation because it is just function
    application! 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Example</span> <span class="id" type="var">update_example1</span> : <span class="id" type="var">examplemap</span> "fau" = <span class="id" type="var">false</span>.<br/>
<div class="togglescript" id="proofcontrol1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')"><span class="show"></span></div>
<div class="proofscript" id="proof1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')">
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">by</span> []. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">update_example4</span> : <span class="id" type="var">examplemap</span> "foo" = <span class="id" type="var">true</span>.<br/>
<div class="togglescript" id="proofcontrol2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')"><span class="show"></span></div>
<div class="proofscript" id="proof2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')">
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">by</span> []. <span class="id" type="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
<a name="lab194"></a><h3 class="section">Exercises</h3>

<div class="paragraph"> </div>

 To use maps in later chapters, we'll need several fundamental
    facts about how they behave. 
    Some of the proofs require the functional
    extensionality axiom discussed in the <span class="inlinecode"><span class="id" type="var">Logic</span></span> chapter, which can be found
    in the standard library and it's imported here. 
<div class="paragraph"> </div>

 First, if we update a map <span class="inlinecode"><span class="id" type="var">m</span></span> at a key <span class="inlinecode"><span class="id" type="var">x</span></span> with a new value <span class="inlinecode"><span class="id" type="var">v</span></span>
    and then look up <span class="inlinecode"><span class="id" type="var">x</span></span> in the map resulting from the <span class="inlinecode"><span class="id" type="var">update</span></span>, we
    get back <span class="inlinecode"><span class="id" type="var">v</span></span>: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <span class="id" type="var">t_update_eq</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">A</span> (<span class="id" type="var">m</span>: <span class="id" type="var">total_map</span> <span class="id" type="var">A</span>) <span class="id" type="var">x</span> <span class="id" type="var">v</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">m</span> [&lt;<span class="id" type="var">x</span> ~~&gt;&gt; <span class="id" type="var">v</span>&gt;] <span class="id" type="var">x</span> = <span class="id" type="var">v</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">move</span>⇒ <span class="id" type="var">A</span> <span class="id" type="var">m</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">by</span> <span class="id" type="tactic">rewrite</span> /<span class="id" type="var">t_update</span> -<span class="id" type="var">beq_string_refl</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
On the other hand, if we update a map <span class="inlinecode"><span class="id" type="var">m</span></span> at a key <span class="inlinecode"><span class="id" type="var">x<sub>1</sub></span></span> and then
    look up a <i>different</i> key <span class="inlinecode"><span class="id" type="var">x<sub>2</sub></span></span> in the resulting map, we get the
    same result that <span class="inlinecode"><span class="id" type="var">m</span></span> would have given. 
<div class="paragraph"> </div>

 Here's a little function that might prove useful: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Check</span> <span class="id" type="var">negbTE</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">t_update_neq</span> : <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) <span class="id" type="var">v</span> <span class="id" type="var">x<sub>1</sub></span> <span class="id" type="var">x<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">m</span> : <span class="id" type="var">total_map</span> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">x<sub>1</sub></span> ≠ <span class="id" type="var">x<sub>2</sub></span> →<br/>
&nbsp;&nbsp;<span class="id" type="var">m</span> [&lt;<span class="id" type="var">x<sub>1</sub></span> ~~&gt;&gt; <span class="id" type="var">v</span>&gt;] <span class="id" type="var">x<sub>2</sub></span> = <span class="id" type="var">m</span> <span class="id" type="var">x<sub>2</sub></span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> /<span class="id" type="var">t_update</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">by</span> <span class="id" type="tactic">move</span> ⇒ ? <span class="id" type="var">v</span> <span class="id" type="var">x<sub>1</sub></span> <span class="id" type="var">x<sub>2</sub></span> <span class="id" type="var">m</span> /<span class="id" type="var">beq_stringP</span>/<span class="id" type="var">negbTE</span> →.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
If we update a map <span class="inlinecode"><span class="id" type="var">m</span></span> at a key <span class="inlinecode"><span class="id" type="var">x</span></span> with a value <span class="inlinecode"><span class="id" type="var">v<sub>1</sub></span></span> and then
    update again with the same key <span class="inlinecode"><span class="id" type="var">x</span></span> and another value <span class="inlinecode"><span class="id" type="var">v<sub>2</sub></span></span>, the
    resulting map behaves the same (gives the same result when applied
    to any key) as the simpler map obtained by performing just
    the second <span class="inlinecode"><span class="id" type="var">update</span></span> on <span class="inlinecode"><span class="id" type="var">m</span></span>: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <span class="id" type="var">t_update_shadow</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">A</span> (<span class="id" type="var">m</span>: <span class="id" type="var">total_map</span> <span class="id" type="var">A</span>) <span class="id" type="var">v<sub>1</sub></span> <span class="id" type="var">v<sub>2</sub></span> <span class="id" type="var">x</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">m</span> [&lt;<span class="id" type="var">x</span> ~~&gt;&gt; <span class="id" type="var">v<sub>1</sub></span>&gt;] [&lt;<span class="id" type="var">x</span> ~~&gt;&gt; <span class="id" type="var">v<sub>2</sub></span>&gt;]<br/>
&nbsp;&nbsp;= <span class="id" type="var">m</span> [&lt;<span class="id" type="var">x</span> ~~&gt;&gt; <span class="id" type="var">v<sub>2</sub></span>&gt;].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">move</span>⇒ ? ? ? ? <span class="id" type="var">x<sub>1</sub></span>. <span class="id" type="tactic">apply</span>: <span class="id" type="var">functional_extensionality</span> ⇒ <span class="id" type="var">x<sub>2</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">by</span> <span class="id" type="tactic">rewrite</span> /<span class="id" type="var">t_update</span>; <span class="id" type="tactic">case</span>: <span class="id" type="var">beq_stringP</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Could this one work w/o functional extensionality? 
<div class="paragraph"> </div>

 Using the example in chapter <span class="inlinecode"><span class="id" type="var">IndProp</span></span> as a template, use
    <span class="inlinecode"><span class="id" type="var">beq_stringP</span></span> to prove the following theorem, which states that if we
    update a map to assign key <span class="inlinecode"><span class="id" type="var">x</span></span> the same value as it already has in
    <span class="inlinecode"><span class="id" type="var">m</span></span>, then the result is equal to <span class="inlinecode"><span class="id" type="var">m</span></span>: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">t_update_same</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">X</span> <span class="id" type="var">x</span> (<span class="id" type="var">m</span> : <span class="id" type="var">total_map</span> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">m</span> [&lt;<span class="id" type="var">x</span> ~~&gt;&gt; <span class="id" type="var">m</span> <span class="id" type="var">x</span>&gt;] = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">move</span>⇒ <span class="id" type="var">X</span> <span class="id" type="var">x<sub>1</sub></span> <span class="id" type="var">m</span>. <span class="id" type="tactic">apply</span>: <span class="id" type="var">functional_extensionality</span> ⇒ <span class="id" type="var">x<sub>2</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> /<span class="id" type="var">t_update</span>. <span class="id" type="tactic">case</span>: <span class="id" type="var">beq_stringP</span> ⇒ //.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">by</span> <span class="id" type="tactic">move</span>⇒ →.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Again, could this one work w/o functional extensionality? 
<div class="paragraph"> </div>

 Use <span class="inlinecode"><span class="id" type="var">beq_stringP</span></span> to prove one final property of the <span class="inlinecode"><span class="id" type="var">update</span></span>
    function: If we update a map <span class="inlinecode"><span class="id" type="var">m</span></span> at two distinct keys, it doesn't
    matter in which order we do the updates. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">t_update_permute</span> : <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) <span class="id" type="var">v<sub>1</sub></span> <span class="id" type="var">v<sub>2</sub></span> <span class="id" type="var">x<sub>1</sub></span> <span class="id" type="var">x<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">m</span> : <span class="id" type="var">total_map</span> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">x<sub>2</sub></span> ≠ <span class="id" type="var">x<sub>1</sub></span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">m</span> [&lt;<span class="id" type="var">x<sub>2</sub></span> ~~&gt;&gt; <span class="id" type="var">v<sub>2</sub></span>&gt;] [&lt;<span class="id" type="var">x<sub>1</sub></span> ~~&gt;&gt; <span class="id" type="var">v<sub>1</sub></span>&gt;]<br/>
&nbsp;&nbsp;=  <span class="id" type="var">m</span> [&lt;<span class="id" type="var">x<sub>1</sub></span> ~~&gt;&gt; <span class="id" type="var">v<sub>1</sub></span>&gt;] [&lt;<span class="id" type="var">x<sub>2</sub></span> ~~&gt;&gt; <span class="id" type="var">v<sub>2</sub></span>&gt;].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">move</span>⇒ <span class="id" type="var">X</span> <span class="id" type="var">v<sub>1</sub></span> <span class="id" type="var">v<sub>2</sub></span> <span class="id" type="var">x<sub>1</sub></span> <span class="id" type="var">x<sub>2</sub></span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span>: <span class="id" type="var">functional_extensionality</span> ⇒ <span class="id" type="var">x<sub>3</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">move</span>: <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> /<span class="id" type="var">t_update</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">move</span>/<span class="id" type="var">beq_stringP</span>/<span class="id" type="var">negbTE</span> ⇒ <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">case</span>: <span class="id" type="var">beq_stringP</span> ⇒ //.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">by</span> <span class="id" type="tactic">move</span>⇒ &lt;-; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Once again, could this one work w/o functional extensionality? 
</div>

<div class="doc">
<a name="lab195"></a><h1 class="section">Partial maps</h1>

<div class="paragraph"> </div>

 Finally, we define <i>partial maps</i> on top of total maps.  A partial
    map with elements of type <span class="inlinecode"><span class="id" type="var">A</span></span> is simply a total map with elements
    of type <span class="inlinecode"><span class="id" type="var">option</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> and default element <span class="inlinecode"><span class="id" type="var">None</span></span>. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">partial_map</span> (<span class="id" type="var">A</span>:<span class="id" type="keyword">Type</span>) := <span class="id" type="var">total_map</span> (<span class="id" type="var">option</span> <span class="id" type="var">A</span>).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">empty</span> {<span class="id" type="var">A</span>:<span class="id" type="keyword">Type</span>} : <span class="id" type="var">partial_map</span> <span class="id" type="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">t_empty</span> <span class="id" type="var">None</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Notation</span> "**" := <span class="id" type="var">empty</span> (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 30).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">update</span> {<span class="id" type="var">A</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">m</span> : <span class="id" type="var">partial_map</span> <span class="id" type="var">A</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">x</span> : <span class="id" type="var">string</span>) (<span class="id" type="var">v</span> : <span class="id" type="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">t_update</span> <span class="id" type="var">m</span> <span class="id" type="var">x</span> (<span class="id" type="var">Some</span> <span class="id" type="var">v</span>).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Notation</span> "cxt ',,' x ':<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>' v " := (<span class="id" type="var">update</span> <span class="id" type="var">cxt</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 21).<br/>
</div>

<div class="doc">
Notation is somewhat different; the reason is we want to use it also, e.g., when talking about contexts in of simply typed lambda calculus in future ... 
<div class="paragraph"> </div>

 We can now lift all of the basic lemmas about total maps to
    partial maps.  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <span class="id" type="var">update_eq</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">A</span> (<span class="id" type="var">m</span>: <span class="id" type="var">partial_map</span> <span class="id" type="var">A</span>) <span class="id" type="var">x</span> <span class="id" type="var">v</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">m</span>,, <span class="id" type="var">x</span> :<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" type="var">v</span>) <span class="id" type="var">x</span> = <span class="id" type="var">Some</span> <span class="id" type="var">v</span>.<br/>
<div class="togglescript" id="proofcontrol3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')"><span class="show"></span></div>
<div class="proofscript" id="proof3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">by</span> <span class="id" type="tactic">move</span>⇒ <span class="id" type="var">A</span> <span class="id" type="var">m</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">rewrite</span> /<span class="id" type="var">update</span> <span class="id" type="var">t_update_eq</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">update_neq</span> : <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) <span class="id" type="var">v</span> <span class="id" type="var">x<sub>1</sub></span> <span class="id" type="var">x<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">m</span> : <span class="id" type="var">partial_map</span> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">x<sub>2</sub></span> ≠ <span class="id" type="var">x<sub>1</sub></span> →<br/>
&nbsp;&nbsp;(<span class="id" type="var">m</span>,, <span class="id" type="var">x<sub>2</sub></span> :<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" type="var">v</span>) <span class="id" type="var">x<sub>1</sub></span> = <span class="id" type="var">m</span> <span class="id" type="var">x<sub>1</sub></span>.<br/>
<div class="togglescript" id="proofcontrol4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')"><span class="show"></span></div>
<div class="proofscript" id="proof4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">by</span> <span class="id" type="tactic">move</span>⇒ <span class="id" type="var">X</span> <span class="id" type="var">v</span> <span class="id" type="var">x<sub>1</sub></span> <span class="id" type="var">x<sub>2</sub></span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> /<span class="id" type="var">update</span> <span class="id" type="var">t_update_neq</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">update_shadow</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">A</span> (<span class="id" type="var">m</span>: <span class="id" type="var">partial_map</span> <span class="id" type="var">A</span>) <span class="id" type="var">v<sub>1</sub></span> <span class="id" type="var">v<sub>2</sub></span> <span class="id" type="var">x</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">m</span>,, <span class="id" type="var">x</span> :<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" type="var">v<sub>1</sub></span>,, <span class="id" type="var">x</span> :<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" type="var">v<sub>2</sub></span> = <span class="id" type="var">m</span>,, <span class="id" type="var">x</span> :<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" type="var">v<sub>2</sub></span>.<br/>
<div class="togglescript" id="proofcontrol5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')"><span class="show"></span></div>
<div class="proofscript" id="proof5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">by</span> <span class="id" type="tactic">move</span>⇒ <span class="id" type="var">A</span> <span class="id" type="var">m</span> <span class="id" type="var">v<sub>1</sub></span> <span class="id" type="var">v<sub>2</sub></span> <span class="id" type="var">x<sub>1</sub></span>; <span class="id" type="tactic">rewrite</span> /<span class="id" type="var">update</span> <span class="id" type="var">t_update_shadow</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">update_same</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">X</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span> (<span class="id" type="var">m</span> : <span class="id" type="var">partial_map</span> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">m</span> <span class="id" type="var">x</span> = <span class="id" type="var">Some</span> <span class="id" type="var">v</span> →<br/>
&nbsp;&nbsp;<span class="id" type="var">m</span>,, <span class="id" type="var">x</span> :<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" type="var">v</span> = <span class="id" type="var">m</span>.<br/>
<div class="togglescript" id="proofcontrol6" onclick="toggleDisplay('proof6');toggleDisplay('proofcontrol6')"><span class="show"></span></div>
<div class="proofscript" id="proof6" onclick="toggleDisplay('proof6');toggleDisplay('proofcontrol6')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">by</span> <span class="id" type="tactic">move</span>⇒ <span class="id" type="var">X</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> /<span class="id" type="var">update</span> -<span class="id" type="var">H</span>; <span class="id" type="tactic">apply</span>: <span class="id" type="var">t_update_same</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">update_permute</span> : <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) <span class="id" type="var">v<sub>1</sub></span> <span class="id" type="var">v<sub>2</sub></span> <span class="id" type="var">x<sub>1</sub></span> <span class="id" type="var">x<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">m</span> : <span class="id" type="var">partial_map</span> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">x<sub>2</sub></span> ≠ <span class="id" type="var">x<sub>1</sub></span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">m</span>,, <span class="id" type="var">x<sub>2</sub></span> :<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" type="var">v<sub>2</sub></span>,, <span class="id" type="var">x<sub>1</sub></span> :<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" type="var">v<sub>1</sub></span><br/>
&nbsp;&nbsp;= <span class="id" type="var">m</span>,, <span class="id" type="var">x<sub>1</sub></span> :<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" type="var">v<sub>1</sub></span>,, <span class="id" type="var">x<sub>2</sub></span> :<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" type="var">v<sub>2</sub></span>.<br/>
<div class="togglescript" id="proofcontrol7" onclick="toggleDisplay('proof7');toggleDisplay('proofcontrol7')"><span class="show"></span></div>
<div class="proofscript" id="proof7" onclick="toggleDisplay('proof7');toggleDisplay('proofcontrol7')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">by</span> <span class="id" type="tactic">move</span>⇒ <span class="id" type="var">X</span> <span class="id" type="var">v<sub>1</sub></span> <span class="id" type="var">v<sub>2</sub></span> <span class="id" type="var">x<sub>1</sub></span> <span class="id" type="var">x<sub>2</sub></span> <span class="id" type="var">m</span>; <span class="id" type="tactic">rewrite</span> /<span class="id" type="var">update</span>; <span class="id" type="tactic">apply</span>: <span class="id" type="var">t_update_permute</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="comment">(*&nbsp;Sun&nbsp;Jul&nbsp;14&nbsp;22:07:54&nbsp;MSK&nbsp;2019&nbsp;*)</span><br/>
</div>
</div>



</div>

</body>
</html>